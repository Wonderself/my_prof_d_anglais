<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta http-equiv="Content-Security-Policy" content="default-src * 'self' blob: data: gap:; style-src * 'self' 'unsafe-inline' blob: data: gap:; script-src * 'self' 'unsafe-eval' 'unsafe-inline' blob: data: gap:; object-src * 'self' blob: data: gap:; img-src * 'self' 'unsafe-inline' blob: data: gap:; connect-src * 'self' 'unsafe-inline' blob: data: gap: ws: wss:; media-src * 'self' blob: data: gap:;">
    <title>Coach Mike</title>
    <style>
        :root {
            --bg-color: #F5F5F7;
            --surface: #FFFFFF;
            --accent: #007AFF;
            --text-primary: #1D1D1F;
            --text-secondary: #86868B;
            --bubble-user: #007AFF;
            --bubble-coach: #E9E9EB;
            --font-stack: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", sans-serif;
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-family: var(--font-stack);
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }
        .header {
            flex: 0 0 auto;
            padding-top: max(15px, env(safe-area-inset-top));
            padding-bottom: 15px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 100;
        }
        .avatar-wrapper {
            position: relative;
            width: 80px;
            height: 80px;
            margin-bottom: 8px;
        }
        .avatar-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            overflow: hidden;
            background: #fff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            position: relative;
            z-index: 2;
            border: 2px solid #fff;
        }
        .avatar-img { width: 100%; height: 100%; object-fit: cover; }
        .speaking-ring {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            border-radius: 50%;
            border: 2px solid var(--accent);
            opacity: 0;
            z-index: 1;
        }
        .is-speaking .speaking-ring { animation: pulse-ring 1.5s infinite ease-out; }
        @keyframes pulse-ring { 0% { transform: scale(1); opacity: 0.6; } 100% { transform: scale(1.4); opacity: 0; } }
        .chat-container {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }
        .bubble {
            max-width: 85%;
            padding: 12px 16px;
            border-radius: 18px;
            font-size: 16px;
            line-height: 1.4;
            animation: popIn 0.3s forwards;
            opacity: 0;
            transform: scale(0.9);
        }
        @keyframes popIn { to { opacity: 1; transform: scale(1); } }
        .bubble.coach { align-self: flex-start; background-color: var(--bubble-coach); color: var(--text-primary); border-bottom-left-radius: 4px; }
        .bubble.user { align-self: flex-end; background-color: var(--bubble-user); color: white; border-bottom-right-radius: 4px; }
        .feedback-box {
            background: rgba(255,255,255,0.6);
            border-radius: 12px;
            padding: 10px;
            margin-top: 8px;
            font-size: 14px;
        }
        .controls-area {
            flex: 0 0 auto;
            background: var(--surface);
            padding: 20px;
            padding-bottom: max(30px, env(safe-area-inset-bottom));
            border-top-left-radius: 24px;
            border-top-right-radius: 24px;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 200;
        }
        .status-label {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 16px;
            height: 20px;
        }
        .mic-button {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: var(--accent);
            border: none;
            color: white;
            font-size: 30px;
            box-shadow: 0 4px 15px rgba(0, 122, 255, 0.4);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.1s;
        }
        .mic-button:active { transform: scale(0.92); }
        .mic-button.recording { background-color: #FF3B30; animation: pulse-red 1.5s infinite; }
        @keyframes pulse-red { 0% { box-shadow: 0 0 0 0 rgba(255, 59, 48, 0.4); } 70% { box-shadow: 0 0 0 15px rgba(255, 59, 48, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 59, 48, 0); } }
        .loader {
            width: 20px; height: 20px; border: 2px solid #f3f3f3; border-top: 2px solid var(--text-secondary); border-radius: 50%; animation: spin 1s linear infinite; display: none;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="header">
        <div class="avatar-wrapper" id="avatar-container">
            <div class="speaking-ring"></div>
            <div class="avatar-circle">
                <img src="https://images.unsplash.com/photo-1500648767791-00dcc994a43e?q=80&w=300&auto=format&fit=crop" class="avatar-img" alt="Coach">
            </div>
        </div>
        <div style="text-align:center;">
            <h1 style="font-size:17px; margin:0;">Coach Mike</h1>
            <p style="font-size:13px; color:#86868B; margin:2px 0 0 0;">American Accent Expert</p>
        </div>
    </div>
    <div class="chat-container" id="chat-area">
        <div class="bubble coach">
            Hello! I'm Mike. üëã<br>Tap the mic to start.
        </div>
    </div>
    <div class="controls-area">
        <div class="status-label" id="status-text">Tap mic to enable</div>
        <div class="loader" id="loader"></div>
        <button class="mic-button" id="mic-btn">üéôÔ∏è</button>
    </div>
    <script>
        const btn = document.getElementById('mic-btn');
        const status = document.getElementById('status-text');
        const chat = document.getElementById('chat-area');
        const avatarContainer = document.getElementById('avatar-container');
        const loader = document.getElementById('loader');
        
        let mediaRecorder;
        let audioChunks = [];
        let isProcessing = false;
        let micInitialized = false;
        
        const synth = window.speechSynthesis;
        let coachVoice = null;

        // --- WARM UP SERVER (Anti-Cold Start) ---
        // D√®s que la page charge, on ping le serveur pour le r√©veiller
        window.onload = () => {
            fetch('/health').then(() => console.log("Server woken up!")).catch(e => console.log("Wake up failed", e));
        };

        function updateStatus(text, processing = false) {
            if (processing) {
                status.style.display = 'none';
                loader.style.display = 'block';
            } else {
                status.style.display = 'block';
                loader.style.display = 'none';
                status.innerText = text;
            }
        }
        function addBubble(type, htmlContent) {
            const bubble = document.createElement('div');
            bubble.className = `bubble ${type}`;
            bubble.innerHTML = htmlContent;
            chat.appendChild(bubble);
            chat.scrollTop = chat.scrollHeight;
        }
        function initVoice() {
            const voices = synth.getVoices();
            coachVoice = voices.find(v => v.lang === 'en-US' && v.name.includes('Male')) 
                      || voices.find(v => v.lang === 'en-US') 
                      || voices.find(v => v.lang.includes('en'));
        }
        if (speechSynthesis.onvoiceschanged !== undefined) speechSynthesis.onvoiceschanged = initVoice;
        initVoice();
        function speak(text) {
            if (synth.speaking) synth.cancel();
            const utter = new SpeechSynthesisUtterance(text);
            if (coachVoice) utter.voice = coachVoice;
            utter.lang = 'en-US';
            utter.onstart = () => avatarContainer.classList.add('is-speaking');
            utter.onend = () => avatarContainer.classList.remove('is-speaking');
            utter.onerror = () => avatarContainer.classList.remove('is-speaking');
            synth.speak(utter);
        }
        async function enableMicrophone() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
                mediaRecorder.onstop = sendAudioToServer;
                micInitialized = true;
                status.innerText = "Hold to speak";
                return true;
            } catch (err) {
                status.innerText = "Mic access required!";
                return false;
            }
        }
        const handleStart = async (e) => {
            if (e.type === 'touchstart') e.preventDefault();
            if (isProcessing) return;
            if (!micInitialized) {
                const success = await enableMicrophone();
                if (!success) return;
                status.innerText = "Ready! Hold to speak";
                return;
            }
            if (synth.speaking) synth.cancel();
            audioChunks = [];
            if (mediaRecorder && mediaRecorder.state === "inactive") {
                mediaRecorder.start();
                btn.classList.add('recording');
                updateStatus("Listening...");
                if (navigator.vibrate) navigator.vibrate(50);
            }
        };
        const handleStop = (e) => {
            if (e.type === 'touchend') e.preventDefault();
            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
                btn.classList.remove('recording');
                updateStatus("", true);
                if (navigator.vibrate) navigator.vibrate(50);
                isProcessing = true;
            }
        };
        btn.addEventListener('mousedown', handleStart);
        btn.addEventListener('mouseup', handleStop);
        btn.addEventListener('mouseleave', handleStop);
        btn.addEventListener('touchstart', handleStart, { passive: false });
        btn.addEventListener('touchend', handleStop, { passive: false });

        async function sendAudioToServer() {
            const blob = new Blob(audioChunks, { type: 'audio/webm' });
            const formData = new FormData();
            formData.append('audio', blob, 'recording.webm');
            
            // --- TIMEOUT CONTROLLER ---
            // Si pas de r√©ponse dans 15s, on coupe tout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000);

            try {
                const response = await fetch('/analyze', { 
                    method: 'POST', 
                    body: formData,
                    signal: controller.signal // Lie le fetch au compte √† rebours
                });
                clearTimeout(timeoutId); // On arr√™te le chrono si r√©ponse re√ßue

                if (!response.ok) throw new Error("Server Error");
                const data = await response.json();
                
                if (data.error) {
                    addBubble('coach', "‚ö†Ô∏è I got confused. Let's try again.");
                } else {
                    addBubble('user', data.transcription || "...");
                    let feedbackHtml = data.coach_response;
                    if (data.pronunciation_feedback) {
                        feedbackHtml += `
                            <div class="feedback-box">
                                <span style="background:#fff; padding:2px 8px; border-radius:10px; font-weight:bold; font-size:12px; color:#007AFF">Score: ${data.score}</span>
                                <div style="color:#FF3B30; font-weight:bold; font-size:11px; text-transform:uppercase; margin-top:6px;">Feedback</div>
                                ${data.pronunciation_feedback}
                                <div style="margin-top:8px; font-weight:600; color:#007AFF">üëâ ${data.next_step}</div>
                            </div>`;
                    }
                    addBubble('coach', feedbackHtml);
                    speak(data.coach_response);
                }
            } catch (error) {
                console.error(error);
                if (error.name === 'AbortError') {
                    addBubble('coach', "‚è±Ô∏è Server took too long. Please try a shorter sentence.");
                } else {
                    addBubble('coach', "Connection error. Check signal.");
                }
            } finally {
                isProcessing = false;
                updateStatus("Hold to speak");
            }
        }
    </script>
</body>
</html>